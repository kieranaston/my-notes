{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kieran's Notes","text":"<p>All my notes in one place.</p> <p>Disclaimer: These are my personal notes, based on various sources. If you recognize any uncited content, please notify me for proper attribution.  </p>"},{"location":"bioinformatics-algorithms/where-in-genome-does-dna-replication-begin/","title":"Where in the genome does DNA replication begin?","text":"<p>Replication begind in a genomic region called the replication origin (denoted \\(oriC\\)).</p> <p>In the context of gene therapy it is important to figure out where the \\(oriC\\) is within the genome so that it can be preserved. This is because it is necessary for gene replication, which is an important part of gene therapy.</p> <p>Research has shown that the region of the bacterial genome encoding \\(oriC\\) is typically a few hundred nucleotides long.</p>"},{"location":"bioinformatics-algorithms/where-in-genome-does-dna-replication-begin/#finding-the-oric","title":"Finding the \\(oriC\\)","text":"<p>One way we can try to find the \\(oriC\\) is by looking for the \\(DnaA\\) box, a DNA sequence that is essentially a message telling the \\(DnaA\\) protein: \"bind here!\"</p> <p>We want to look for something that stands out in \\(oriC\\), in other words, some sort of pattern.</p> <p>One way we can define this problem is as a pattern counting problem, where we search for the most frequent \\(k\\)-mers, or, strings of length \\(k\\).</p> <p>We can use the following algorithm:</p> <pre><code>def pattern_count(text, pattern):\n    count = 0\n    for i in range(0, len(text)-len(pattern)):\n        if text[i:(i+len(pattern))] == pattern:\n            count += 1\n    return count\n</code></pre>"},{"location":"bioinformatics-algorithms/where-in-genome-does-dna-replication-begin/#the-frequent-words-problem","title":"The Frequent Words problem","text":"<p>Let us extend this further. We can generalize to wanting to find the most frequent \\(k\\)-mer for all values of \\(k\\) possible for the text.</p> <p>We say that \\(Pattern\\) is a most frequent \\(k\\)-mer in \\(Text\\) if it mazimizes <code>pattern_count(text, pattern)</code> among all \\(k\\)-mers.</p> <p>So our problem is as follows:</p> <p>Input: A string \\(Text\\) and an integer \\(k\\)</p> <p>Output: All most frequent \\(k\\)-mers in \\(Text\\)</p> <p>There will be \\(|Text|-k+1\\) \\(k\\)-mers to check in a given string \\(Text\\).</p> <p>To implement this algorithm <code>frequent_words</code> we need to store an array <code>count</code> containing the number of occurrences of each pattern \\(Pattern = Text(i,k)\\), where <code>count[i]</code> stores <code>count(text, pattern)</code> for \\(Pattern = Text(i,k)\\). So if we have a pattern of length 3, <code>count[2]</code> would be the number of occurrences of the substring from index 2 to index (2 + 3) - 1 = 4.</p> <p>Here is the algorithm:</p> <pre><code>def frequent_words(text, k):\n    count = []\n    frequent_patterns = []\n    max_count = 0\n    for i in range(0, len(text)-k):\n        pattern = text[i:(i+k)]\n        count.append(pattern_count(text, pattern))\n        if count[i] &gt; max_count:\n            max_count = count[i]\n    for i in range(0, len(text)-k):\n        if count[i] == max_count:\n            frequent_patterns.append(text[i:(i+k)])\n    frequent_patterns = list(dict.fromkeys(frequent_patterns))\n    return frequent_patterns\n</code></pre> <p>This works, but it is not very efficient.</p> <p>Each \\(k\\)-mer requires \\(|Text| - k + 1\\) checks, each requiring as many as \\(k\\) comparisons, so overall # of steps of <code>pattern_count(text, pattern)</code> is \\((|Text| - k + 1) \\cdot k\\).</p> <p>Additionally, <code>frequent_words</code> must call <code>pattern_count</code> \\(|Text| - k + 1\\) times (once for each \\(k\\)-mer of \\(Text\\)), so its overall number of steps is \\((|Text| - k + 1) \\cdot (|Text| - k + 1) \\cdot k\\).</p> <p>To simplify, its complexity is \\(\\mathcal{O}(|Text|^2\\cdot k)\\).</p>"},{"location":"bioinformatics-algorithms/where-in-genome-does-dna-replication-begin/#references","title":"References","text":"<p>Compeau, P., &amp; Pevzner, P. (2015). Bioinformatics algorithms: An active learning approach (Vol. 1). Active Learning Publishers.</p>"},{"location":"linux-essentials/linux-administration/utility-commands-user-management/","title":"Utility commands and user management","text":""},{"location":"linux-essentials/linux-administration/utility-commands-user-management/#linux-file-editor","title":"Linux file editor","text":"<p>Several standard text editors on most Linux systems:</p> <ul> <li><code>vi</code> visual editor</li> <li><code>ed</code> standard line editor</li> <li><code>ex</code> extended line editor</li> <li><code>emacs</code> a full screen editor</li> <li><code>pico</code> beginner's editor</li> <li><code>vim</code> advanced version of vi</li> </ul> <p>Will focus on <code>vi</code> because it is usually available on every Linux system and is easy to learn.</p>"},{"location":"linux-essentials/linux-administration/utility-commands-user-management/#most-common-vi-commands","title":"Most common <code>vi</code> commands","text":"<p><code>i</code> insert <code>Esc</code> escape out of any mode <code>r</code> replace <code>d</code> delete <code>:q!</code> quit without saving <code>:wq!</code> quit and save</p> <p>When you enter <code>vi</code> you will be in command mode. The other mode is the typing (insert) mode.</p> <p>To enter typing mode you hit <code>i</code> or \"insert\".</p> <p>To save you could shift + z z. Or you could do <code>:wq!</code></p>"},{"location":"linux-essentials/linux-command-line/commands-and-permissions/","title":"Commands and permissions","text":"<p>Commands syntax:</p> <pre><code>command option(s) argument(s)\n</code></pre>"},{"location":"linux-essentials/linux-command-line/commands-and-permissions/#options","title":"Options","text":"<p>Options modify the way a command works, and usually consist of a dash followed by a single letter.</p> <p>Multiple options can be grouped together after a single hyphen.</p>"},{"location":"linux-essentials/linux-command-line/commands-and-permissions/#arguments","title":"Arguments","text":"<p>Most commands are used with one or more arguments.</p> <p>Some commands assume a default argument if none is supplied.</p> <p>Arguments are optional for some commands and required by others.</p>"},{"location":"linux-essentials/linux-command-line/commands-and-permissions/#useful-commands","title":"Useful commands","text":"<p><code>whoami</code> to determine which user you are.</p> <p><code>pwd</code> to display your directory.</p> <p><code>cd</code> to move about directories.</p> <p><code>ls</code> to see items within working directory.</p> <p><code>cp</code> to copy a file from one directory to another.</p> <ul> <li>The third column in file info tells you the owner of the file.</li> <li>The fourth column is the group name for that file.</li> <li>Fifth column gives number of bytes for the file.</li> <li><code>ll</code> gives same result as <code>ls -l</code></li> </ul> <p><code>rm -f</code> to delete a file without confirming, <code>rm -r</code> to delete a directory.</p> <p><code>mkdir</code> to create a directory.</p> <p><code>man</code> with a command as argument to see man page for a command.</p> <p><code>date</code> gives the date on your system.</p> <p><code>more</code> gives output one page at a time. Piping with more is useful.</p> <p><code>tail</code> gives last line of an output. Also useful in piping.</p> <p><code>cat</code> reads contents of a file.</p> <p>To become a super user (root user) use <code>sm -</code> and enter your password.</p> <ul> <li>To leave root user account: <code>exit</code></li> </ul>"},{"location":"linux-essentials/linux-command-line/commands-and-permissions/#permissions","title":"Permissions","text":"<p><code>r</code> - read <code>w</code> - write <code>x</code> - execute = running a program</p> <p>Each permission can be controlled at three different levels:</p> <p><code>u</code> - user <code>g</code> - group <code>o</code> - other = everyone on the system</p> <p>To see file or directory permissions run <code>ls -l</code>:</p> <p>Example: <code>-rwxrwxrwx</code></p> <p>First bit indicates a file, next three bits are user permissions, then next three are group, and last three are permissions for others.</p> <p><code>chmod</code> can be used to change permissions.</p> <p>Example: Removing group write permissions from file <code>testfile</code>: <code>chmod g-w testfile</code> Example: Removing write permissions for everyone from file <code>testfile</code>: <code>chmod a-w testfile</code></p>"},{"location":"linux-essentials/linux-command-line/commands-and-permissions/#file-ownership","title":"File ownership","text":"<p><code>chown</code> changes the ownership of a file.</p> <p>Example: To change the ownership from a user to root: <code>chown root testfile</code></p> <p><code>chgrp</code> changes the group ownership of a file.</p> <p>The <code>-R</code> option changes ownership recursively (everything within will also have ownership changed).</p> <p>Note: If a file you do not have ownership of is within a directory that you have permissions for, you can still delete/make changes to it. For this reason is it often important to perform recursive ownership changes to ensure they are properly applied for your case.</p> <p>Source: Linux for Absolute Beginners: Commands and Permissions by Imran Afzal, Allison.</p>"},{"location":"linux-essentials/linux-command-line/file-commands/","title":"File commands","text":""},{"location":"linux-essentials/linux-command-line/file-commands/#file-display-commands","title":"File display commands","text":"<ul> <li><code>cat</code> views entire content</li> <li><code>more</code> views one page at a time</li> <li><code>less</code> views content in reverse order, one page at time</li> <li><code>head</code> gives the first few lines</li> <li><code>tail</code> gets you the last lines of a file</li> </ul>"},{"location":"linux-essentials/linux-command-line/file-commands/#file-maintenance-commands","title":"File maintenance commands","text":"<ul> <li><code>cp</code> copies a file from one location to another</li> <li><code>rm</code> removes a file</li> <li><code>mv</code> used to move location of file from one to another, or rename it</li> <li><code>mkdir</code> makes a directoy</li> <li><code>rmdir</code> or <code>rm -r</code> removes directory</li> <li><code>chgrp</code> changes group ownership</li> <li><code>chown</code> changes ownership</li> </ul> <p>Source: Linux for Absolute Beginners: File Commands and Filters by Imran Afzal, Allison.</p>"},{"location":"linux-essentials/linux-command-line/file-comparison-and-splitting/","title":"File comparison and splitting","text":""},{"location":"linux-essentials/linux-command-line/file-comparison-and-splitting/#cut-command","title":"Cut command","text":"<p>Cut is a command utility that allows you to cut parts of lines from specific files or piped data and print the result to standard output.</p> <p>Can be used to cut parts1 of a line by a delimiter, byte position, and character.</p> <p><code>cat -c1 filename</code> list one character <code>cut -c1,2,4</code> pick and choose character(s) <code>cut -c1-3 filename</code> list range of characters <code>cut -c1-3, 6-8 filename</code> list by specific range of characters <code>cut -b1-3 filename</code> list by byte size <code>cut -d: -f 6 /etc/passwd</code> list first 6th column separated by : <code>cut -d: -f 6-7 /etc/passwd</code> list first 6 and 7th column separated by : <code>ls -l | cut -c2-4</code> only print user permissions of files/dir</p>"},{"location":"linux-essentials/linux-command-line/file-comparison-and-splitting/#compare-files","title":"Compare files","text":"<p><code>diff</code> compares line by line <code>cmp</code> compares byte by byte</p>"},{"location":"linux-essentials/linux-command-line/file-comparison-and-splitting/#comtining-and-plitting-files","title":"Comtining and plitting files","text":"<p>Multiple files can be combined into one, and one file can be split into multiple files.</p> <p>In times when we have huge files, there are times when we need to either split them or compress them to send them places.</p> <p><code>split -l 2 countries sep</code> splits the file countries into files with name <code>sep</code> containing 2 lines each from original countries file</p>"},{"location":"linux-essentials/linux-command-line/file-comparison-and-splitting/#linux-vs-windows-commands","title":"Linux vs. Windows commands","text":"<p>Listing of a directory: <code>dir</code> vs <code>ls -l</code> Rename a file: <code>ren</code> vs <code>mv</code> Copy a file: <code>copy</code> vs <code>cp</code> Move file: <code>move</code> vs <code>mv</code> Clear screen: <code>cls</code> vs <code>clear</code> Delete file: <code>del</code> vs <code>rm</code> Compare contents of files: <code>fc</code> vs <code>diff</code> Search for a word/string in a file: <code>find</code> vs <code>grep</code> Display command help: <code>command /?</code> vs <code>man command</code> Displays your location in the file system: <code>chdir</code> vs <code>pwd</code> Displays the time: <code>time</code> vs <code>date</code></p> <p>Source: Linux for Absolute Beginners: File Comparison and Splitting by Imran Afzal, Allison.</p>"},{"location":"linux-essentials/linux-command-line/help-commands-and-pipes/","title":"Help commands and pipes","text":""},{"location":"linux-essentials/linux-command-line/help-commands-and-pipes/#help-commands","title":"Help commands","text":"<p>3 types of help commands:</p> <ul> <li><code>whatis command</code></li> <li>Gives shorter version of command info</li> <li><code>command --help</code></li> <li>Longer version of help for command</li> <li><code>man command</code></li> <li>Full info for command</li> </ul>"},{"location":"linux-essentials/linux-command-line/help-commands-and-pipes/#tab-and-up-arrow","title":"Tab and up arrow","text":"<p>Tab completes available commands, files, or directories.</p> <p>Up arrow gives the last executed command.</p>"},{"location":"linux-essentials/linux-command-line/help-commands-and-pipes/#pipes","title":"Pipes","text":"<p>Pipes are used to connect the output of one command to the input of another command.</p> <p>The symbol for a pipe is <code>|</code>. Syntax for using pipes is:</p> <pre><code>command1 [arguments] | command2 [arguments]\n</code></pre>"},{"location":"linux-essentials/linux-command-line/help-commands-and-pipes/#adding-text-to-files","title":"Adding text to files","text":"<p>3 simple ways:</p> <ul> <li><code>vi</code> editor</li> <li>Redirect command output <code>&gt;</code> or <code>&gt;&gt;</code></li> <li><code>echo &gt;</code> or <code>&gt;&gt;</code></li> </ul> <p>Example using redirect: <code>echo \"Jerry is the main character in Seinfeld\" &gt; jerry</code> populates file <code>jerry</code> with that text.</p> <p>Doing it with <code>&gt;</code> will overwrite contents. <code>&gt;&gt;</code> will add to the existing contents.</p> <p>Can also send the output of a command to a file this way.</p> <p>Source: Linux for Absolute Beginners: Help Command and Pipes by Imran Afzal, Allison.</p>"},{"location":"linux-essentials/linux-command-line/text-and-grep-commands/","title":"Text and grep commands","text":""},{"location":"linux-essentials/linux-command-line/text-and-grep-commands/#filterstext-processors-commands","title":"Filters/text processors commands","text":"<ul> <li><code>cut</code> cut output of command</li> <li><code>awk</code> list by the columns</li> <li><code>grep</code> and <code>egrep</code> search by keywords</li> <li><code>sort</code> sorts output</li> <li><code>uniq</code> no duplicates in output</li> <li><code>wc</code> word count</li> </ul> <p>Example of <code>grep</code>: To search for directories with user read and write permissions: <code>ls -l | grep drw</code></p>"},{"location":"linux-essentials/linux-command-line/text-and-grep-commands/#grep-usage","title":"<code>grep</code> usage","text":"<p><code>grep keyword file</code> gives only the lines of <code>file</code> that contain <code>keyword</code> <code>grep -c keyword file</code> this searches for a keyword and counts it <code>grep -i KEYword file</code> searches for keyword but ignore case <code>grep -n keyword file</code> displays the matched lines and line numbers <code>grep -v keyword file</code> get everything but the search keyword <code>grep keyword file | awk '(print $1)'</code> gives only first columns of the lines returned <code>ls -l | grep Desktop</code> only pull results that include \"Desktop\" <code>egrep -i \"keyword|keyword2\" file</code> gives all lines matching either of the keywordsx</p>"},{"location":"linux-essentials/linux-command-line/text-and-grep-commands/#wc-usage","title":"<code>wc</code> usage","text":"<p>Reads either standard input or list of files and generates: newline count, word count, byte count.</p> <p><code>wc file</code> checks file line count, word count, byte count <code>wc -l file</code> gets number of lines in a file <code>wc -w file</code> gets number of words in a file <code>wc -b file</code> gets number of bytes in a file</p> <p><code>ls -l | wc -l</code> gives the number of files/directories you have within a location (plus 1 extra line counted)</p>"},{"location":"linux-essentials/linux-command-line/text-and-grep-commands/#awk-usage","title":"<code>awk</code> usage","text":"<p>Most of the time <code>awk</code> is used to extract fields from a file or from an output.</p> <p>Source: Linux for Absolute Beginners: Text and Grep Commands by Imran Afzal, Allison.</p>"}]}