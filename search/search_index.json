{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kieran's notes","text":"<p>All my notes in one place.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/computer-assisted-surgery/","title":"Computer-assisted Surgery","text":"<p>Image-guided surgery is using visualizations that are images to help a surgeon perform a surgery.</p> <p>Computer-assisted surgery is using technology somehow to improve the execution of surgery.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/computer-assisted-surgery/#how-we-approach-an-operation","title":"How we approach an operation","text":"<p>In each phase of an operation, i.e., pre-operative, intra-operative, and post-operative we have a workflow utilizing imaging, our patient-specific model, and out computer-assisted plan.</p> <p>All aspects are working dynamically and changing each other.</p> <p>At the end we put everything into a database.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/computer-assisted-surgery/#system-design","title":"System design","text":"<p>When desiging systems we have to consider that there are loads of different brands of equipment and software.</p> <p>When designing a system it is complete with navigation software, hardware interface, and hardware.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/computer-assisted-surgery/#challenges","title":"Challenges","text":"<p>Image segmentation, i.e., determining the meaningful sections of an image.</p> <p>Spatial registration, i.e., determining the transformation between two coordinate frames (or images).</p>"},{"location":"surgical-data-science/computer-assisted-surgery/fiducial-registration/","title":"Fiducial Registration","text":"<p>Since we have previously achieved a method of determining the position of the tooltip and tool in the tracker (world) coordinate system, we now need a way of seeing that info in the actual image/scan.</p> <p>This means we need to align the image with the actual physical head, or in other words, determine the transformation from the world to the image.</p> <p>We can use fiducial registration for this. By identifying points on the patient's anatomy in both the image and the physical world and determining the transformation between those pairs of points we can align the virtual model with the real anatomy.</p> <p>So we have points \\(\\mathbf{p}_i\\) whose position we know in the image/scan (\\(B\\)) and the reference/world as tracker sees it (\\(A\\)).</p> <p>We are trying to find a transformation \\(R^{B \\rightarrow A}, \\mathbf{t}^{B \\rightarrow A}\\) than minimizes the following:</p> \\[ \\sum_i\\lvert\\lvert\\mathbf{p}_i^A-(R^{B \\rightarrow A}\\mathbf{p}_i^B+\\mathbf{t}^{B \\rightarrow A})\\rvert\\rvert^2 \\] <p>Which is the error (distance) between the transformed points in \\(B\\) and their corresponding points in \\(A\\).</p>"},{"location":"surgical-data-science/computer-assisted-surgery/fiducial-registration/#finding-the-translation","title":"Finding the translation","text":"<p>We want to minimize:</p> \\[ \\sum_i\\lvert\\lvert\\mathbf{p}_i^A-\\mathbf{p}_i^B+\\mathbf{t}^{B \\rightarrow A}\\rvert\\rvert^2 \\] <p>If we expand the function we are trying to minimize:</p> \\[ =\\sum_i(\\mathbf{p}_i^{A^T}\\mathbf{p}_i^A+\\mathbf{p}_i^{B^T}\\mathbf{p}_i^B-2\\mathbf{p}_i^{A^T}\\mathbf{p}_i^B+2(\\mathbf{p}_i^A-\\mathbf{p}_i^B)^T\\mathbf{t}^{B \\rightarrow A}+\\mathbf{t}^{B \\rightarrow A^T}\\mathbf{t}^{B \\rightarrow A}) \\] <p>We can say \\(c = \\mathbf{p}_i^{A^T}\\mathbf{p}_i^A+\\mathbf{p}_i^{B^T}\\mathbf{p}_i^B-2\\mathbf{p}_i^{A^T}\\mathbf{p}_i^B\\)</p> <p>And simplify the rest to the following:</p> \\[ \\mathbf{t}^{B \\rightarrow A^T}(nI)\\mathbf{t}^{B \\rightarrow A}+2\\left[\\sum_i(\\mathbf{p}_i^A-\\mathbf{p}_i^B)\\right]^T\\mathbf{t}^{B \\rightarrow A}+c \\] <p>Here we are just starting out with the assumption that our optimal rotation is just the identity matrix. When we further simplify this equation we get something like a quadratic. Using a method similar to finding the vertex of a quadratic, we find that it is minimized by:</p> <p>\\(\\mathbf{t}^{B \\rightarrow A}=(nI)^{-1}(\\sum_i(\\mathbf{p}_i^A-\\mathbf{p}_i^B))\\) \\(=\\frac{1}{n}\\sum_i(\\mathbf{p}_i^A-\\mathbf{p}_i^B)\\) \\(=\\frac{1}{n}\\sum_i\\mathbf{p}_i^A-\\frac{1}{n}\\sum_i\\mathbf{p}_i^B\\)</p> <p>We find that to get the translation we find the centroid in \\(A\\) and the centroid in \\(B\\) and take the difference.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/fiducial-registration/#rotation","title":"Rotation","text":"<p>For rotation, we want to minimize with respect to the rotation from \\(B \\rightarrow A\\).</p> <p>Basically we want to maximize:</p> \\[ \\sum_i\\mathbf{p}^{A^T}_iR^{B \\rightarrow A}\\mathbf{p}^B_i \\] <p>This is summing the dot product of each point in \\(A\\) and its corresponding rotated point from \\(B \\rightarrow A\\). The dot product between the actual point and the rotated point originally from \\(B\\) is representative of the correlation between the transformed points. So, maximizing this will give us the most accurate rotation.</p> <p>Solution, compute: \\(H=\\sum_i\\mathbf{p}_i^B\\mathbf{p}_i^T\\)</p> <p>Then compute the singular value decomposition of \\(H\\).</p> \\[ H=U \\]"},{"location":"surgical-data-science/computer-assisted-surgery/fiducial-registration/#observations","title":"Observations","text":"<p>Lambda is matrix of singular values.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/pivot-calibration-and-spin-calibration/","title":"Pivot calibration &amp; spin calibration","text":"<p>So say we have a reference frame defined by a sensor on a head or something, in addition to a frame for the scalpel tip, the scalpel, and the image.</p> <p>Our goal is to get the transformation from the scalpel tip to the image: \\(T^{\\text{ScalpelTip} \\rightarrow \\text{Image}}\\)</p> <p>This transformation is given by the product of the following transformations:</p> \\[ T^{\\text{ScalpelTip} \\rightarrow \\text{Image}} = T^{\\text{Reference}\\rightarrow \\text{Image}}T^{\\text{Scalpel}\\rightarrow \\text{Reference}}T^{\\text{ScalpelTip}\\rightarrow \\text{Scalpel}} \\] <p>Our goal is to get the position of the scalpel tip in the image coordinate system. 1. Transform from scalpel tip to scalpel 2. Transform from scalpel to reference (frame for the tracker on head) 3. Transform from reference to image (so that we correctly see the location of the scalpel tip in the image)</p> <p>Transformation from Reference \\(\\rightarrow\\) Image:</p> <p>This transformation is fixed because the reference tracker stays in the same spot.</p> <p>Transformation from Scalpel \\(\\rightarrow\\) Reference:</p> <p>This transformation describes the position of the scalpel relative to the reference tracker.</p> <p>It is obtained dynamically from the tracking system.</p> <p>Transformation from ScalpelTip \\(\\rightarrow\\) Scalpel:</p> <p>Since the scalpel tip has a known, fixed offset from the scalpel's main tracking point, this is a static transformation assuming the scalpel shape does not change.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/pivot-calibration-and-spin-calibration/#how-do-we-find-the-transformation-from-the-tooltip-coordinate-frame-to-the-tool-coordinate-frame","title":"How do we find the transformation from the tooltip coordinate frame to the tool coordinate frame?","text":"<p>Finding the translation: Pivot calibration</p> <p>The idea is to think of the tooltip as the center of a sphere, with the main tool tracker being offset from it by some distance along the shaft of the scalpel. Then as we rotate the tool, the main tool tracker will be at points along the surface of the sphere, distanced from the tooltip by the radius of the sphere.</p> <p>We call \\([x_i^{\\text{Tr}}, y_i^{\\text{Tr}}, z_i^{\\text{Tr}}]\\) the origin of the tool coordinate frame with respect to the tracker (attached to the tool).</p> <p>We call \\([x_c^{\\text{Tr}}, y_c^{\\text{Tr}}, z_c^{\\text{Tr}}]\\) the centre of the sphere with respect to the tracker.</p> <p>We call \\(r\\) the sphere's radius.</p> <p>From the equation for the radius of a sphere, we see that the following must be true:</p> \\[ (x_1-x_c)^2+(y_1-y_c)^2+(z_1-z_c)^2=r^2 \\] <p>When simplifying this we see that:</p> \\[ -2x_ix_c-2y_iy_c-2z_iz_c+(x_c^2-y_c^2+z_c^2-r^2)=-x_i^2-y_i^2-z_i^2 \\] <p>We observe that \\(d = (x_c^2-y_c^2+z_c^2-r^2)\\) is a constant term and we can solve for it later once we find the coordinates of the tooltip.</p> <p>We end up with the following system of equations in matrix form (for multiple points on the surface of the sphere \\(i=1, 2, \\dots, n\\)):</p> \\[ \\begin{bmatrix}-2x_i &amp; -2y_i &amp; -2z_i &amp; 1\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots\\\\-2x_n &amp; -2y_n &amp; -2z_n &amp; 1\\end{bmatrix}\\begin{bmatrix}x_c\\\\y_c\\\\z_c\\\\d\\end{bmatrix}=\\begin{bmatrix}-x_i^2-y_i^2-z_i^2\\\\ \\vdots\\\\-x_n^2-y_n^2-z_n^2\\end{bmatrix} \\] <p>This equation takes the form: \\(A\\mathbf{x}=\\mathbf{b}\\)</p> <p>And we can solve for the sphere's center \\(\\mathbf{x}\\) like so:</p> \\[ \\mathbf{x}=(A^TA)^{-1}A^T\\mathbf{b} \\] <p>This gave us \\(d\\) as well, so we can now calculate the radius:</p> \\[ r^2=d-x_c^2-y_c^2-z_c^2 \\] <p>What did we achieve? We now have the position of the tooltip relative to the tracker, as well as the distance from the tool sensor to the tooltip.</p> <p>What do we need now?</p> <p>We got \\([x_c^{\\text{Tr}}, y_c^{\\text{Tr}}, z_c^{\\text{Tr}}]\\) (position of the tooltip with respect to the tracker), but we want \\([x_c^{\\text{Tool}}, y_c^{\\text{Tool}}, z_c^{\\text{Tool}}]\\) (the position of the tooltip relative to the tool, which is the other tracker on the scalpel).</p> \\[ \\begin{bmatrix}x_c^{\\text{Tool}}\\\\y_c^{\\text{Tool}}\\\\z_c^{\\text{Tool}}\\\\1\\end{bmatrix}=T^{\\text{Tracker}\\rightarrow\\text{Tool}}\\begin{bmatrix}x_c^{\\text{Tr}}\\\\y_c^{\\text{Tr}}\\\\z_c^{\\text{Tr}}\\\\1\\end{bmatrix} \\] <p>This is simply multiplying the given transformation from the tracker to the tool by the tooltip position relative to the tracker that we just obtained.</p> <p>Once we have the position of the tooltip relative to the tool, to get the transformation from tooltip to tool it is just a translation:</p> \\[ T^{\\text{Tooltip} \\rightarrow \\text{Tool}}=\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; x_c^{\\text{Tool}} \\\\ 0 &amp; 1 &amp; 0 &amp; y_c^{\\text{Tool}}\\\\ 0 &amp; 0 &amp; 1 &amp; z_c^{\\text{Tool}} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] <p>This is a homeogeneous transformation matrix representing the translation from the tooltip to the tool.</p> <p>Finding the rotation: Spin calibration</p> <p>Remember our goal is to determine a transformation from the tool coordinate frame to the tracker (world) frame. We already got the translation with pivot calibration, now we will get the rotation with spin calibration.</p> <p>Call \\(R_i^{\\text{Tool} \\rightarrow \\text{Tracker}}, R_J^{\\text{Tool} \\rightarrow \\text{Tracker}}\\)</p> <p>These describe different orientations of the tool at different times.</p> \\[ R^{\\text{Tool}_i \\rightarrow \\text{Tool}_j}=(R^{\\text{Tracker} \\rightarrow \\text{Tool}_j})(R^{\\text{Tracker} \\rightarrow \\text{Tool}_i}) \\] <p>We get the product of those different orientations to determine the relative rotation, which should be around the tool's fixed rotation axis. We can call this \\(R\\).</p> <p>\\(R\\mathbf{v}=\\mathbf{v}\\) such that \\(\\lvert\\lvert \\mathbf{v} \\rvert\\rvert\\) for all instantaneous rotations.</p> <p>We are essentially asking, \"what single axis explains all these rotations?</p> <p>Now we want to find \\(\\mathbf{v}\\) minimizing the following:</p> <p>\\(\\mathbf{v}^T\\left[\\sum_{i, j}(R-I)^T(R-I)\\right]\\mathbf{v}\\) such that \\(\\lvert\\lvert \\mathbf{v}\\rvert\\rvert = 1\\)</p> <p>This essentially measures how much the observed rotations deviate from being purely around the axis \\(\\mathbf{v}\\).</p> <p>We can say that \\(M=\\sum_{i, j}(R-I)^T(R-I)\\)</p> <p>We can take \\(\\mathbf{v}\\) as the eigenvector of \\(M\\) with the smallest eigenvalue (which represents the least deviation from the assumption that all rotations are around \\(\\mathbf{v}\\)).</p> <p>\\(\\mathbf{v}\\) is in the tool coordinate frame.</p> \\[ T^{\\text{Tooltip} \\rightarrow \\text{Tool}}=\\begin{bmatrix}\\mathbf{v} &amp; \\mathbf{u}_1 &amp; \\mathbf{u}_2 &amp; \\mathbf{t}\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix} \\] <p>\\(\\mathbf{u}_1, \\mathbf{u}_2\\) are orthogonal to \\(\\mathbf{v}\\)</p> <p>What we just defined is our tool coordinate frame. It contains our axis of rotation, the other axes (orthogonal to our rotation axis), and the translation vector from the tool's origin to the tooltip.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/","title":"Transformation representations","text":""},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#euler-angle-representation","title":"Euler angle representation","text":"\\[ R_Z(\\gamma)=\\begin{bmatrix}\\cos \\gamma &amp; -\\sin \\gamma &amp; 0\\\\ \\sin \\gamma &amp; \\cos \\gamma &amp; 0\\\\ 0 &amp; 0 &amp; 1\\end{bmatrix} \\] \\[ R_Y(\\beta)=\\begin{bmatrix}\\cos \\beta &amp; 0 &amp; \\sin \\beta\\\\ 0 &amp; 1 &amp; 0\\\\ -\\sin \\beta &amp; 0 &amp; \\cos \\beta\\end{bmatrix} \\] \\[ R_X(\\alpha)=\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\ 0 &amp; \\cos \\alpha &amp; -\\sin \\alpha\\\\ 0 &amp; \\sin \\alpha &amp; \\cos \\alpha\\end{bmatrix} \\] <p>Performs these rotations sequentially: \\(R=R_Z(\\gamma)R_Y(\\beta)R_X(\\alpha)\\)</p> <p>Some sequences and angles (like \\(ZYX\\), or \\(\\beta=\\pm90^\\circ\\)) can lead to a loss of one degree of freedom.</p> <p>Order matters, so some ambiguity there.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#rotation-matrix-representation","title":"Rotation matrix representation","text":"<p>If we multiply our euler angle rotations into a single matrix, we get a rotation matrix that performs the entire rotation in one matrix multiplication operation.</p> <p>We can also add an extra dimension (homogeneous coordinates) to combine rotation and translation into a single matrix. The top-right 3x1 vector is the translation vector, and the bottom row would be [0 0 0 1]. To make this work we add another dimension to the vector we are multiplying as well, 1 if it is a point (position vector), 0 if it is a direction (or normal vector).</p> \\[ T=\\begin{bmatrix}R &amp; t\\\\0 &amp; 1\\end{bmatrix}=\\begin{bmatrix}T_{11} &amp; T_{12} &amp; T_{13} &amp; t_x\\\\ T_{21} &amp; T_{22} &amp; T_{23} &amp; t_y\\\\ T_{31} &amp; T_{32} &amp; T_{33} &amp; t_z\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix} \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#axis-angle-representation","title":"Axis angle representation","text":"<p>If we have a rotation matrix, we can find the axis (a unit vector) and the angle \\(\\theta\\) so that rotating around the axis by \\(\\theta\\) gives the same result as the rotation matrix.</p> <p>The trace of a matrix is related to the angle we want. The trace of a rotation matrix is given by: \\(1 + 2\\cos \\theta\\).</p> <p>We can calculate the trace and solve for theta: \\(\\cos \\theta = (\\text{trace} - 1)/2\\). Then \\(\\theta\\) would be the arccos of that value:</p> \\[ \\theta = \\arccos(\\frac{\\text{trace}(R)-1}{2}) \\] <p>The axis of rotation is the vector that remains unchanged by the rotation matrix. So, if \\(\\bf{v}\\) were the axis then \\(R\\bf{v}=\\bf{v}\\). Thus, \\(\\bf{v}\\) is an eigenvector of \\(R\\). An eigenvector of a matrix \\(R\\) is a non-zero vector \\(\\bf{v}\\) such that when you multiply \\(R\\) by \\(\\bf{v}\\), you get a scalar multiple of \\(\\bf{v}\\). That scalar is the eigenvalue \\(\\lambda\\). So ematically, the eigenvalue must satisfy \\(R\\bf{v}=\\lambda\\bf{v}\\). Since with this eigenvector we have \\(R\\bf{v}=\\bf{v}\\), we know that the eigenvalue of \\(\\bf{v}\\) must be 1.</p> <p>This makes sense because the axis is the line around which everything else rotates, so it should stay fixed.</p> <p>So for any rotation matrix \\(R\\), we know there exists an eigenvector \\(\\bf{v}\\) with eignevalue 1.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#finding-the-axis-vector","title":"Finding the axis vector","text":"<p>For \\(\\theta \\neq 0, \\pi\\):</p> <ol> <li>Extract axis components from the off-diagonal terms of \\(R\\):</li> </ol> \\[ \\bf{v}=\\begin{bmatrix}R_{32}-R_{23}\\\\R_{13}-R_{31}\\\\R_{21}-R_{12}\\end{bmatrix} \\] <ol> <li>Normalize the axis vector:</li> </ol> \\[ \\bf{v}_{\\text{axis}}=\\frac{\\bf{v}}{2\\sin \\theta} \\] <p>Special case for \\(\\theta=\\pi(180^\\circ)\\)</p> <p>If \\(\\theta=\\pi\\), compute the axis components as:</p> \\[ \\bf{v}=\\begin{bmatrix}\\pm\\sqrt{(R_{11}+1)/2}\\\\ \\pm\\sqrt{(R_{22}+1)/2}\\\\ \\pm\\sqrt{(R_{33}+1)/2}\\end{bmatrix} \\] <p>where signs are chosen to match the signs of \\(R_{21},R_{32},R_{13}\\).</p> <p>The unique cases we are covering are as follows:</p> <p>\\(\\theta=0\\): No unique axis. \\(\\theta=\\pi\\): Axis signs depend on off-diagnonal terms.</p> <p>Real-life scenarios where these edge cases might arise include: * If the rotation is net-zero, creating the problem that there is no unique axis that remains unchanged (they all do)     * Algorithms expecting a single axis may fail * Half-rotation (\\(180^\\circ\\)) makes the standard normalization of the axis vector fail because \\(\\sin180^\\circ=0\\). Also sign ambiguities     * Could result in miscalculation of rotation axis</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#quaternions","title":"Quaternions","text":"<p>A quaternion has 4 components:</p> \\[ \\bf{q}=w+x\\bf{i}+y\\bf{j}+z\\bf{k} \\] <p>\\(w\\): The scalar (real number) part. \\(x, y, z\\): The vector (imaginary) parts. \\(\\bf{i}, \\bf{j}, \\bf{k}\\): Imaginary units with properties \\(\\bf{i}^2=\\bf{j}^2=\\bf{k}^2=\\bf{i}\\bf{j}\\bf{k}=-1\\)</p> <p>A quaternion encoding a 3D rotation is defined by: 1. Rotation Axis: A 3D unit vector \\(\\bf{v}=(v_x,v_y,v_z)\\) 2. Rotation Angle: \\(\\theta\\) (in radians)</p> \\[ \\bf{q}=cos\\frac{\\theta}{2}+\\sin\\frac{\\theta}{2}\\cdot(v_x\\bf{i}+v_y\\bf{j}+v_z\\bf{k}) \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#sum-of-quaternions","title":"Sum of quaternions","text":"\\[ q=q_w+q_xi+q_yj+q_zk \\] \\[ p=p_w+p_xi+p_yj+p_zk \\] \\[ q+p=q_w+p_w+(q_x+p_x)i+(q_y+p_y)j+(q_z+p_z)k \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#product-of-quaternions","title":"Product of quaternions","text":"<p>\\(i^2=-1\\), \\(j^2=-1\\), \\(k^2=-1\\)</p> <p>\\(ij=k=-ji\\)</p> <p>\\(jk=i=-kj\\)</p> <p>\\(ki=j=-ik\\)</p> <p>Multiplication is not commutative.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#complex-conjugate","title":"Complex conjugate","text":"<p>\\(q=q_w+q_xi+q_yj+q_zk\\)</p> <p>\\(q^*=q_w-q_xi-q_yj-q_zk\\)</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#inverse","title":"Inverse","text":"\\[ q^{-1}=\\frac{q^*}{\\lvert\\lvert q \\rvert\\rvert^2} \\] <p>...or if \\(q\\) has unit length: \\(q^{-1}=q^*\\)</p> <p>\\(q^{-1}\\) is a number such that \\(qq^{-1}=1\\)</p> <p>\\(\\lvert\\lvert q \\rvert\\rvert^2=qq^*=q_w^2+q_x^2+q_y^2+q_z^2\\)</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#properties-of-quaternions","title":"Properties of quaternions","text":"<p>If we have \\(\\bf{v}, \\theta\\), then our quaternion could look like:</p> \\[ q=\\begin{bmatrix}\\cos\\frac{\\theta}{2}\\\\\\bf{v}_x\\sin\\frac{\\theta}{2}\\\\\\bf{v}_y\\sin\\frac{\\theta}{2}\\\\\\bf{v}_z\\sin\\frac{\\theta}{2}\\end{bmatrix} \\] <p>If two rotations have different angles, then their quaternion representations must also differ in the scalar component.</p> <p>If two rotations have different rotation axes, then their quaternion representations must also differ in at least one of the vector components.</p> <p>If two quaternions have different scalar components, then their corresponding rotation angles must be different.</p> <p>If the vector components of two quaternions differ in at least one coordinate, then the corresponding rotation axes must be different.</p> <p>The point is, quaternion representations are unique.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#applying-rotations","title":"Applying rotations","text":"<p>Suppose we have a point \\(\\bf{p}^A\\) and we know \\(q^{A \\rightarrow B}\\):</p> <p>\\(\\bf{p}^B=q^{A \\rightarrow B}\\bf{p}^A(q^{A \\rightarrow B})^*\\)</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#composing-rotations","title":"Composing rotations","text":"<p>If we know \\(q^{A \\rightarrow B}\\) and \\(q^{B \\rightarrow C}\\) then \\(q^{A \\rightarrow C} = q^{B \\rightarrow C}q^{A \\rightarrow B}\\).</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformation-representations/#pros-and-cons-of-different-rotation-methods","title":"Pros and cons of different rotation methods","text":"Rotation method Pros Cons Euler angles Intuitive Ambiguity in ordering convention; numerical instability Rotation matrices Allows homogeneous representation; easy to apply, invert, and combine Many parameters Axis angle Intuitive; can calculate size of rotation Need to compute eigenvalues Quaternions Easy to convert to axis-angle; easy to apply, invert, and combine Poor intuition"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/","title":"Transformations","text":"<p>In both 2D and 3D, it is worth noting that the determinant represents the following:</p> <ol> <li>If \\(\\det(R) &gt; 1\\), the transformation increases the scale</li> <li>If \\(\\det(R) &lt; 0\\), the transformation flips the space (like a mirror reflection)</li> <li>The absolute value of the determinant gives the scaling factor by which the transformation changes areas/volumes</li> <li>If \\(\\det(R)=1\\) it means that the transformation does not change the area or volume of the object - only orientation</li> </ol> <p>An orthogonal matrix has a determinant of either +1 or -1. For rotation matrices it is +1, for reflection matrices it is -1. For both of these types of transfromations the lengths of vectors and the angles between them are preserved.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#linear-transformations","title":"Linear transformations","text":"\\[ \\bf{y}=A\\bf{x} \\] <p>For example:</p> \\[ \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix} \\begin{bmatrix} x\\\\ y \\end{bmatrix} \\begin{bmatrix} ax + by\\\\ cx + dy \\end{bmatrix} \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#rotations-in-2d","title":"Rotations in 2D","text":"<p>Can view them as linear transformations with a rotation matrix and a vector:</p> \\[ \\bf{p}' = R(\\theta) = \\begin{bmatrix} \\cos \\theta &amp; -\\sin\\theta\\\\ \\sin \\theta &amp; \\cos \\theta \\end{bmatrix} \\] <p>Properties:</p> <ol> <li>\\(R(\\theta_1)R(\\theta_2)=R(\\theta_1+\\theta_2)\\)<ol> <li>The operation of combining rotations is additive in terms of the angles when rotating in 2D.</li> </ol> </li> <li>\\(\\det(R(\\theta))=1\\)<ol> <li>The determinant of a 2D rotation matrix is always 1. The determinant of a transformation matrix represents how the area scales under the transformation, and since a rotation in 2D preserves shape and dimensions the scaling factor is always 1.</li> </ol> </li> <li>\\(R(-\\theta)=R(\\theta)^T\\)<ol> <li>A rotation by \\(-\\theta\\) undoes a rotation by \\(\\theta\\). The transpose of a matrix swaps rows and columns, which geometrically corresponds to \"flipping\" the rotation direction.</li> </ol> </li> <li>\\(R(-\\theta)=R(\\theta)^T=R(\\theta)^{-1}\\)<ol> <li>Orthogonal when referring to vectors means vectors that are perpendicular to each other. In the context of matrices, it means a matrix that preserves the lengths and angles of vectors it transforms. Rotation matrices do that, so rotation matrices are orthogonal.</li> </ol> </li> <li>\\(\\lvert\\lvert R(\\theta)\\bf{x} \\rvert\\rvert = \\lvert\\lvert \\bf{x} \\rvert\\rvert\\)<ol> <li>Rotation matrices preserve magnitude (or length) of the vector they transform.</li> </ol> </li> <li>The rotation matrix is only dependent on the argument's value modulo \\(2\\pi\\).<ol> <li>This is because rotations cycle by \\(2\\pi\\), so we only care about the remainder when divided by \\(2\\pi\\) when we talk about a rotation. We want to divide out the full rotations, and whatever we are left with is all that matters.</li> </ol> </li> </ol>"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#rotations-in-3d","title":"Rotations in 3D","text":"<p>Can be represented by a matrix equation: \\(\\bf{p}'=R\\bf{p}\\)</p> <p>With \\(R\\) being a 3x3 rotation matrix.</p> <p>Properties of 3D rotation matrices: 1. Composition is also a rotation matrix \\(R_1R_2\\)     1. If we multiply two rotation matrices together, the result is also a rotation matrix. 2. \\(R_1R_2 \\neq R_2R_1\\) unless shared axis     1. If the axis is shared, it is kind of just like rotating in 2D, so that property applies. 3. \\(\\det(R)=1\\)     1. Just like in 2D, rotations in 3D preserve lengths and angles, so the scaling factor will always be 1 for a rotation, hence the determinant being 1. 4. \\(R^T=R^-1\\), or \\(RR^T=R^TR=I\\)     1. Same as 2D, rotation matrices do not change the dimensions of shapes only orientation, so they are orthogonal. 5. Vector norms are invariant     1. When a rotation matrix is applie to a vector, the length of the vector remains unchanged.</p> <p>Each of the three columns of a 3x3 rotation matrix can be thought of as the coordinates of each of the basis vectors/axes of the axes after rotation.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#scaling","title":"Scaling","text":"<p>2D axis-aligned scaling: \\(S(s_x,s_y)=\\begin{bmatrix}s_x &amp; 0\\\\0 &amp; s_y\\end{bmatrix}\\)</p> <p>Generalized to \\(n\\)-D space: \\(S(\\bf{s})=diag(\\bf{s})\\)</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#compositions-of-linear-transformations","title":"Compositions of linear transformations","text":"<p>Performing 2 linear transformations sequentially is equivalent to 1 linear transformation whose matrix is the product of the individual transformation matrices. Suppose that \\(T_1(\\bf{x})\\) and \\(T_2(\\bf{x})\\) are both linear transformations with matrices \\(A\\) and \\(B\\), respectively:</p> \\[ \\bf{z}=T_1(T_2(\\bf{x})) \\] <p>Expanding this into matrix products:</p> \\[ \\bf{z}=AB\\bf{x} \\] <p>Say we want to scale by \\(s\\) in direction \\(\\bf{v}\\) where \\(\\bf{v}\\) is a unit vector. We can think: 1. Rotate by \\(\\theta\\) so that the direction is aligned with \\(X\\), then 2. Axis-aligned scaling 3. Rotate back to original coordinate frame</p> \\[ A=R(-\\theta)S(s,1)R(\\theta) \\] <p>Rotation of a direction \\(\\bf{v}\\) to the \\(X\\) axis happens to be given by:</p> \\[ R(\\theta)=\\begin{bmatrix}v_x &amp; v_y\\\\-v_y &amp; v_x\\end{bmatrix} \\] <p>So from \\(A=R(-\\theta)S(s,1)R(\\theta)\\) we get:</p> \\[ I+(s-1)\\begin{bmatrix}v^2_x &amp; v_xv_y\\\\v_xv_y &amp; v^2_y\\end{bmatrix} \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#rigid-transformations","title":"Rigid transformations","text":"<p>Examples of rigid transformations are translation and rotation.</p> <p>Have 2 properties in 2D: 1. Distance between 2 points do not change 2. In 2D, orientation of any triangle does not change, in 3D, the orientation and volume of any tetrahedron does not change</p> <p>The form of a rigid transformations is rotation \\(R\\) followed by translation \\(t\\):</p> \\[ T(\\bf{x})=R\\bf{x} + \\bf{t} \\] <p>Which is a rotation about the origin, then translation.</p> <p>If we want a different center of rotation \\(c\\), we can follow these steps: 1. Translate and make \\(\\bf{c}\\) the origin 2. Rotate around \\(\\bf{c}\\) by \\(R\\) 3. Translate back</p> \\[ T(\\bf{x})=R(\\bf{x}-\\bf{c})+\\bf{c} \\] <p>Given two rigid transformations: $$ T_1(\\bf{x})=R_1\\bf{x}+\\bf{t_1} $$</p> \\[ T_2(\\bf{x})=R_2\\bf{x}+\\bf{t_2} \\] <p>Then \\(T_1 \\cdot T_2\\) is operation of performing \\(T_2\\) first, then \\(T_1\\).</p> <p>If \\(\\bf{y}=T_2(\\bf{x})\\) and \\(\\bf{z}=T_1(\\bf{y})\\) then we obtain:</p> \\[ \\bf{z}=T_1(T_2(\\bf{x}))=R_1(R_2\\bf{x}+\\bf{t}_2) + \\bf{t}_1 \\] <p>By distributive property:</p> \\[ \\bf{z}=R_1R_2\\bf{x}+R_1\\bf{t}_2+\\bf{t_1} \\] <p>Simply a rigid transformation with rotation matrix \\(R_1R_2\\) and translation by \\((R_1\\bf{t}_2+\\bf{t}_1)\\).</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#inverse-transformations","title":"Inverse transformations","text":"<p>Inverse of a rotation matrix is its transpose.</p> <p>Translations are inverted by translating in the negative direction.</p> <p>Linear transforms \\(A\\bf{x}\\) are invertible only if the matrix is invertible, with the inverse transformation \\(A^{-1}\\bf{x}\\).</p> <p>Rigid transformations also invertible:</p> \\[ T^{-1}_{(R, \\bf{t})}=T_{(R^T, -R^T_{\\bf{t}})} \\] <p>Where \\(T_{(R, \\bf{t})}(\\bf{x})=R_{\\bf{x}}+\\bf{t}\\)</p>"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#rigid-movement","title":"Rigid movement","text":"<p>Purpose is to represent movement of rigid bodies in space.</p> <p>Given a rigid body in 2D that has been translated by \\(\\bf{t}\\) and rotated by \\(R=R(\\theta)\\):</p> <p>If \\(\\bf{x}\\) gives the coordinates of a position \\(P\\) that is attached to the body, then after moving, \\(P\\) will have coordinates \\(T_p(\\bf{x})\\) relative to the original body's frame:</p> \\[ T_p(\\bf{x}) = R\\bf{x} + \\bf{t} \\] <p>However, if the transformation of directional coordinates will simply be a rotation and ignore translation:</p> \\[ T_d(\\bf{v}) = R\\bf{v} \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#representation-of-coordinate-frames-and-coordinate-transforms","title":"Representation of coordinate frames and coordinate transforms","text":"<p>Coordinate frames, as well as conversions between them, are interpreted as rigid transformations.</p> <p>We can rep a 2D coordinate frame \\(F\\) with origin \\(O\\) and axes \\(X\\) and \\(Y\\) by the coordinates of \\(O\\), \\(X\\), and \\(Y\\) in some world frame \\(W\\). If \\(O\\) has coordinates \\(\\bf{t}\\), and \\(X\\) and \\(Y\\) have (directional) coordinates \\(\\bf{x}=(x_1,x_2)\\) and \\(\\bf{y}=(y_1,y_2)\\) relative to \\(W\\), then the world coordinates of any point \\(P\\) such that \\(\\bf{p}\\) is its coordinates in the frame \\(F\\) can be calculated by the rigid transform:</p> \\[ \\bf{p}_W=\\begin{bmatrix}x_1 &amp; y_1\\\\x_2 &amp; y_2\\end{bmatrix}\\bf{p}+\\bf{t} \\] <p>We discussed earlier how the columns of a rotation matrix can be thought of simply as the coordinates of the axes after rotation.</p> <p>So this rigid transformation performs a rotation on a point from the frame \\(F\\) so that its coordinates are expressed relative to the axes of \\(W\\), then performs a translation to account for the offset between the origin of \\(F\\) and the origin of the world frame \\(W\\).</p> <p>So if we store the rotation matrix and the translation that gets us to the origin we can perform this calculation for any point in \\(F\\).</p> <p>The reverse coordinate transform from \\(W \\rightarrow F\\) can also be performed by applying the inverse transform (note that we apply the translation first):</p> \\[ \\bf{p}_F=R^T(\\bf{p}_W-\\bf{t}) \\] <p>We can also do changes of coordinate frames with rigid transforms. Suppose \\(A\\) and \\(B\\) are two coordinate frames, where \\(A\\) is represented with respect to the world frame by a rotation matrix \\(R_A\\) and translation \\(\\bf{t}_A\\), and \\(B\\) is represented by \\(R_B\\) and \\(\\bf{t}_B\\). Then given the coordinates \\(\\bf{p}^A\\) of some point \\(P\\) relative to \\(A\\), we can determine \\(P\\)'s coordinates relative to \\(\\bf{p}^B\\) in two steps.</p> <p>So we have a coordinate \\(P\\) relative to coordinate frame \\(A\\), and we want to determine its position relative to coordinate frame \\(B\\).</p> <p>We have the rigid transform to get points from \\(A\\) in the world frame, as well as the rigid transform to get points from \\(B\\) in the world frame.</p> <p>First, we calculate the world coordinates of point \\(\\bf{p}^A\\):</p> \\[ \\bf{p}^W=T_A(\\bf{p}^A) \\] <p>We then perform the inverse of \\(B\\) coordinates to the newly found world coordinates to get the point's coordinates with respect to \\(B\\):</p> \\[ \\bf{p}^B=T^{-1}_B(\\bf{p}^W)=R^T_B(\\bf{p}^W-\\bf{t}_B) \\] <p>This transform can be calculated for all points by composing the transformation from the frame \\(A\\) for the world frame \\(W\\) and the transformation from the world frame \\(W\\) back to \\(B\\):</p> \\[ \\bf{p}^B=T^{-1}_B(T_A(\\bf{p}^A))=R_B^TR_A\\bf{p}^A+R_B^T(\\bf{t}_A-\\bf{t}_B) \\]"},{"location":"surgical-data-science/computer-assisted-surgery/transformations/#homogeneous-coordinate-representations","title":"Homogeneous coordinate representations","text":"<p>Without an extra coordinate, translations cannot be represented by a matrix. Translation adds a fixed value, whereas matrix multiplication always involves scaling or rotating. The extra 1 in the coordinates of a point allows the translation to \"participate\" in the matrix multiplication. With this idea we can represent a 2D rigid transformation of both positions and directions with a 3x3 matrix multiplication:</p> \\[ \\hat{T}(\\hat{\\bf{x}})=\\begin{bmatrix}\\cos\\theta &amp; -\\sin\\theta &amp; t_x\\\\\\sin\\theta &amp; \\cos\\theta &amp; t_y\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\hat{\\bf{x}} \\] <p>Where the original transformation \\(T(\\bf{x})=R(\\theta)\\bf{x}+\\bf{t}\\) is a rotation about \\(\\theta\\) followed by translation \\(\\bf{t}=(t_x,t_y)\\).</p> <p>We can do the same sort of thing for 3D.</p> <p>The nice thing about this is that transform application is a matrix-vector multiply, transform composition is a matrix-matrix multiple, and transform inversion is a matrix inversion.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/vectors-and-coordinates/","title":"Vectors &amp; Coordinates","text":""},{"location":"surgical-data-science/computer-assisted-surgery/vectors-and-coordinates/#coordinate-frames","title":"Coordinate frames","text":"<p>A 2D position \\(P\\): $$ \\mathbf{p}=(p_x,p_y) $$ with \\(X\\), \\(Y\\), and origin \\(O\\).</p> <p>A 3D position \\(P\\): $$ \\mathbf{p}=(p_x,p_y,p_z) $$ with \\(X\\), \\(Y\\), \\(Z\\), and origin \\(O\\).</p> <p>Note that for 3D we use a right-handed frame (thumb is \\(X\\), index is \\(Y\\), middle is \\(Z\\)).</p>"},{"location":"surgical-data-science/computer-assisted-surgery/vectors-and-coordinates/#directional-quantities","title":"Directional quantities","text":"<p>Displacement from \\(\\mathbf{p} \\rightarrow \\mathbf{q}\\): $$ \\mathbf{q} - \\mathbf{p} $$ Has direction and magnitude.</p> <p>Direction from \\(\\mathbf{p} \\rightarrow \\mathbf{q}\\): $$ \\frac{\\mathbf{q}-\\mathbf{p}}{\\lVert \\mathbf{q}-\\mathbf{p} \\rVert} $$ Only has magnitude.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/vectors-and-coordinates/#geometric-operations","title":"Geometric operations","text":"<p>\\(\\mathbf{p}\\) after displacement \\(\\mathbf{d}\\): $$ \\mathbf{p} + \\mathbf{d} $$</p> <p>Interpolation and extrapolation: $$ \\mathbf{x}(u)=(1-u)\\mathbf{p}+u\\mathbf{q} $$ for \\(u \\in \\mathbb{R}\\).</p> <p>Interpolation starts at \\(\\mathbf{x}(0)=\\mathbf{p}\\) at \\(u=0\\), ends at \\(\\mathbf{x}(1)=\\mathbf{q}\\) at \\(u=1\\). When \\(u&lt;0\\) or \\(u&gt;1\\), extrapolation.</p> <p>Defining line passing through \\(p\\) and \\(q\\) using orthogonal vector: $$ \\mathbf{x}\\cdot(\\mathbf{p}-\\mathbf{q})^\\perp=\\mathbf{p}\\cdot(\\mathbf{p}-\\mathbf{q})^\\perp $$</p> <p>Can also use this simplified representation: $$ \\mathbf{x}\\cdot \\mathbf{n}=c $$</p>"},{"location":"surgical-data-science/computer-assisted-surgery/what-is-surgical-data-science/","title":"Surgical Data Science","text":"<p>Surgical data science aims to improve the quality of interventional healthcare and its value though capturing, organization, analysis, and modeling of data.</p> <p>Surgery is any physical manipulation of a tool on a patient's body.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/what-is-surgical-data-science/#the-problem","title":"The Problem","text":"<p>More knowledge to sift through \\(\\rightarrow\\) less feasible to translate that knowledge into actionable insights.</p> <p>Surgical data science can help physicians sift through data and figure out what actions to take.</p>"},{"location":"surgical-data-science/computer-assisted-surgery/what-is-surgical-data-science/#data","title":"Data","text":"<p>Many different types from before, during, and after surgery:</p> <ul> <li>Medical images</li> <li>Navigation data</li> <li>Patient status data</li> <li>Surgeon status data</li> <li>Resource utilization</li> <li>Medical records</li> <li>Expert knowledge</li> </ul>"},{"location":"surgical-data-science/computer-assisted-surgery/what-is-surgical-data-science/#applications","title":"Applications","text":"<ul> <li>Decision support</li> <li>Smart operating room assistant</li> <li>Data-Driven operating room scheduling</li> <li>Training</li> <li>Monitoring surgeon fatigue</li> <li>Assessing new technologies tntroduced into OR</li> <li>Identifying steps of the surgery that need improvement</li> <li>Best post-operative care plan</li> </ul>"},{"location":"surgical-data-science/computer-assisted-surgery/what-is-surgical-data-science/#challenges","title":"Challenges","text":"<ol> <li>Cost of error</li> <li>Accountability</li> <li>Heterogeneity in patients, anatomy, and disease</li> <li>Machine collaboration with clinicians</li> </ol>"},{"location":"surgical-data-science/computer-assisted-surgery/what-is-surgical-data-science/#how-do-we-approach-problems","title":"How do we approach problems?","text":"<ul> <li>What is going on?</li> <li>How well is it going?</li> <li>What is next?</li> </ul> <p>This approach is enabled by time series classification.</p>"}]}